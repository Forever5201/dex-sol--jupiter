# ç³»ç»Ÿè·¯ç”±å†³ç­–æœºåˆ¶ - å®Œæ•´æŠ€æœ¯è§£æ

## ç›®å½•
1. [æ€»ä½“æ¶æ„](#æ€»ä½“æ¶æ„)
2. [è§¦å‘å†³ç­–æµç¨‹](#è§¦å‘å†³ç­–æµç¨‹)
3. [è·¯ç”±æ¨¡å¼é€‰æ‹©](#è·¯ç”±æ¨¡å¼é€‰æ‹©)
4. [ä¸‰å±‚ç®—æ³•è¯¦è§£](#ä¸‰å±‚ç®—æ³•è¯¦è§£)
5. [ä¼˜åŒ–ç­–ç•¥](#ä¼˜åŒ–ç­–ç•¥)
6. [å®é™…æ¡ˆä¾‹](#å®é™…æ¡ˆä¾‹)

---

## æ€»ä½“æ¶æ„

æ‚¨çš„å¥—åˆ©ç³»ç»Ÿé‡‡ç”¨**äº‹ä»¶é©±åŠ¨ + å®šæ—¶æ‰«æ**çš„æ··åˆæ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä»·æ ¼æ•°æ®æº                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ Raydium  â”‚  â”‚  Orca    â”‚  â”‚ Meteora  â”‚  ... å¤šä¸ªDEX  â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â”‚
â”‚       â”‚             â”‚             â”‚                      â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                     â”‚                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   WebSocket è®¢é˜…å±‚      â”‚
         â”‚  (å®æ—¶ä»·æ ¼æµ)           â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   ä»·æ ¼ç¼“å­˜ (PriceCache) â”‚
         â”‚  + ä¸‰å±‚è¿‡æ»¤æœºåˆ¶         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   äº‹ä»¶å¹¿æ’­ (Broadcast)  â”‚
         â”‚  PriceUpdateEvent      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   ä¸»äº‹ä»¶å¾ªç¯           â”‚
         â”‚  (Event Loop)          â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   è·¯ç”±å†³ç­–å¼•æ“          â”‚
         â”‚  (AdvancedRouter)      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   å¥—åˆ©æœºä¼š              â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## è§¦å‘å†³ç­–æµç¨‹

### é˜¶æ®µ1: ä»·æ ¼ç›‘æ§ä¸åˆæ­¥è¿‡æ»¤

#### ğŸ“Š WebSocketå®æ—¶è®¢é˜…
```rust
// ä½ç½®ï¼šsrc/websocket.rs
// ç³»ç»Ÿè®¢é˜…æ‰€æœ‰é…ç½®çš„æ± å­ï¼Œå®æ—¶æ¥æ”¶ä»·æ ¼æ›´æ–°
"accountSubscribe" â†’ æ± å­è´¦æˆ·æ•°æ® â†’ è§£æ â†’ è®¡ç®—ä»·æ ¼
```

**è®¢é˜…çš„å†…å®¹**ï¼š
- æ± å­ä¸»è´¦æˆ·ï¼ˆåŒ…å«reserveå’Œä»·æ ¼ä¿¡æ¯ï¼‰
- Vaultè´¦æˆ·ï¼ˆç”¨äºæŸäº›DEXå¦‚Phoenixï¼‰
- æ¯æ¬¡SolanaåŒºå—é“¾çŠ¶æ€å˜åŒ–éƒ½ä¼šæ¨é€

#### ğŸ” ä¸‰å±‚è¿‡æ»¤æœºåˆ¶ï¼ˆå…³é”®ï¼ï¼‰

##### **Filter 1: æ— æ•ˆä»·æ ¼è¿‡æ»¤**
```rust
// ä½ç½®ï¼šsrc/price_cache.rs:92-110
if new_price == 0.0 || old == 0.0 {
    return 0.0;  // âŒ æ‹’ç»ï¼šä»·æ ¼ä¸º0è¡¨ç¤ºæ± å­æœªåˆå§‹åŒ–æˆ–å¼‚å¸¸
}
```

**ä¸ºä»€ä¹ˆè¦è¿™æ ·**ï¼š
- æ–°å»ºçš„æ± å­å¯èƒ½price=0
- æµåŠ¨æ€§æ¯ç«­çš„æ± å­ä¼šè¿”å›0
- é¿å…é™¤ä»¥0çš„é”™è¯¯

##### **Filter 2: å™ªå£°è¿‡æ»¤ï¼ˆå¾®å°å˜åŒ–ï¼‰**
```rust
let change = ((new_price - old) / old * 100.0).abs();
if change == 0.0 {
    return 0.0;  // âŒ å®Œå…¨ç›¸åŒï¼Œæ— éœ€å¤„ç†
} else if change < 0.001 {
    return 0.0;  // âŒ å˜åŒ–<0.001%è§†ä¸ºå™ªå£°ï¼ˆæµ®ç‚¹è¯¯å·®ï¼‰
}
```

**å®é™…æ¡ˆä¾‹**ï¼š
```
æ—§ä»·æ ¼: 168.123456789
æ–°ä»·æ ¼: 168.123456790  
å˜åŒ–ç‡: 0.0000000059% â† è¿™æ˜¯å™ªå£°ï¼
```

**ä¸ºä»€ä¹ˆ0.001%**ï¼š
- Solanaçš„slotæ—¶é—´çº¦400-500ms
- é«˜é¢‘æ›´æ–°ä¼šäº§ç”Ÿå¤§é‡å¾®å°æŠ–åŠ¨
- 0.001%ä»¥ä¸‹å˜åŒ–å¯¹å¥—åˆ©æ— æ„ä¹‰ï¼ˆæ‰‹ç»­è´¹çº¦0.25%ï¼‰

##### **Filter 3: æ˜¾è‘—æ€§é˜ˆå€¼è¿‡æ»¤**
```rust
// ä½ç½®ï¼šsrc/main.rs:507-511
if !event.price_change_percent.is_finite() || 
   event.price_change_percent < event_config.price_change_threshold_percent {
    filtered_count += 1;
    continue;  // âŒ å˜åŒ–ä¸å¤Ÿæ˜¾è‘—
}
```

**é»˜è®¤é˜ˆå€¼ï¼š1.0%** ï¼ˆå¯é…ç½®ï¼‰

**ä¸ºä»€ä¹ˆ1%**ï¼š
- å¥—åˆ©éœ€è¦è¦†ç›–ï¼š
  - DEXæ‰‹ç»­è´¹ï¼š0.25% - 0.3%ï¼ˆæ¯è·³ï¼‰
  - Gasè´¹ç”¨ï¼šçº¦0.002 SOL â‰ˆ 0.5 USDC
  - æ»‘ç‚¹æŸå¤±ï¼š0.1% - 0.5%
- **1%ä»·æ ¼å˜åŒ–** æ‰æœ‰å¯èƒ½äº§ç”Ÿå‡€åˆ©æ¶¦ >0

**ç»Ÿè®¡æ•°æ®**ï¼ˆç³»ç»Ÿå®é™…è¿è¡Œï¼‰ï¼š
```
æ¯ç§’æ¥æ”¶äº‹ä»¶: ~100-200ä¸ª
Filter 1è¿‡æ»¤: ~5-10% (æ— æ•ˆä»·æ ¼)
Filter 2è¿‡æ»¤: ~70-80% (å™ªå£°)
Filter 3è¿‡æ»¤: ~10-15% (ä¸æ˜¾è‘—)
å®é™…è§¦å‘: ~1-5% (5-10ä¸ª/ç§’)
```

---

### é˜¶æ®µ2: Debounceï¼ˆé˜²æŠ–ï¼‰æœºåˆ¶

#### ğŸ• æ—¶é—´é˜²æŠ–
```rust
// ä½ç½®ï¼šsrc/main.rs:521-529
// ç­‰å¾…é…ç½®çš„å»¶è¿Ÿæ—¶é—´
tokio::time::sleep(Duration::from_millis(event_config.debounce_ms)).await;

// æ£€æŸ¥è·ç¦»ä¸Šæ¬¡æ‰«æçš„æ—¶é—´
let elapsed = last_scan_trigger.elapsed();
if elapsed < Duration::from_millis(event_config.debounce_ms) {
    println!("â­ï¸ Skipped: debounce not satisfied");
    continue;
}
```

**é»˜è®¤debounce: 500ms**

**ä¸ºä»€ä¹ˆéœ€è¦Debounce**ï¼š

**åœºæ™¯1ï¼šè¿ç»­ä»·æ ¼å˜åŒ–**
```
T=0ms:    SOL/USDC ä»·æ ¼ 168 â†’ 170 (å˜åŒ–1.2%) âœ“ è§¦å‘
T=100ms:  SOL/USDC ä»·æ ¼ 170 â†’ 171 (å˜åŒ–0.6%) âœ— è¢«debounceæ‹’ç»
T=200ms:  SOL/USDC ä»·æ ¼ 171 â†’ 172 (å˜åŒ–0.6%) âœ— è¢«debounceæ‹’ç»
T=500ms:  ç°åœ¨å¯ä»¥è§¦å‘æ–°æ‰«æ
```

**åœºæ™¯2ï¼šå¤šæ± å­åŒæ—¶å˜åŒ–**
```
T=0ms:   Pool A: ä»·æ ¼å˜åŒ–1.5% â†’ è§¦å‘æ‰«æ
T=50ms:  Pool B: ä»·æ ¼å˜åŒ–1.2% â†’ è¢«debounceé˜»æ­¢ï¼ˆå¤ªå¿«ï¼‰
T=100ms: Pool C: ä»·æ ¼å˜åŒ–2.0% â†’ è¢«debounceé˜»æ­¢
T=500ms: ä¸‹ä¸€ä¸ªäº‹ä»¶å¯ä»¥è§¦å‘
```

**å¥½å¤„**ï¼š
1. é¿å…"ä»·æ ¼æš´åŠ¨"æ—¶æ‰«æè¿‡äºé¢‘ç¹
2. ç­‰å¾…ä»·æ ¼ç¨³å®šåå†æ‰«æï¼ˆæ›´å‡†ç¡®ï¼‰
3. å‡å°‘è®¡ç®—èµ„æºæµªè´¹

---

### é˜¶æ®µ3: å¹¶å‘æ§åˆ¶ï¼ˆSemaphoreï¼‰

#### ğŸš¦ ä¿¡å·é‡é™åˆ¶
```rust
// ä½ç½®ï¼šsrc/main.rs:534-535
if let Ok(permit) = scan_semaphore.clone().try_acquire_owned() {
    scan_count += 1;
    // å…è®¸æ‰«æ
} else {
    // âŒ å·²ç»æœ‰å¤ªå¤šæ‰«æåœ¨è¿›è¡Œï¼Œè·³è¿‡
}
```

**é»˜è®¤å¹¶å‘ä¸Šé™ï¼š3ä¸ªæ‰«æ**

**ä¸ºä»€ä¹ˆé™åˆ¶å¹¶å‘**ï¼š

**CPUä½¿ç”¨æƒ…å†µ**ï¼š
```
å•æ¬¡Completeæ‰«æ:
- Quickæ‰«æ:  ~5% CPU,  4ms
- BFSæ‰«æ:    ~8% CPU,  4ms  
- Bellman-Ford: ~15% CPU, 14ms
æ€»è®¡: ~28% CPU, 22ms

å¦‚æœæ— é™åˆ¶å¹¶å‘ï¼š
- 10ä¸ªå¹¶å‘æ‰«æ = 280% CPU (è¶…è½½ï¼)
- å†…å­˜å ç”¨ = 10 * 50MB = 500MB
```

**å®é™…æ•ˆæœ**ï¼š
```
æƒ…å†µAï¼šæ­£å¸¸å¸‚åœº
  å¹¶å‘æ‰«ææ•°: 0-1ä¸ª
  CPUä½¿ç”¨ç‡: 10-20%
  
æƒ…å†µBï¼šé«˜æ³¢åŠ¨å¸‚åœº
  å¹¶å‘æ‰«ææ•°: 2-3ä¸ªï¼ˆä¸Šé™ï¼‰
  CPUä½¿ç”¨ç‡: 50-60%
  å¤šä½™è§¦å‘è¢«æ‹’ç»ï¼Œä¿æŠ¤ç³»ç»Ÿç¨³å®š
```

---

## è·¯ç”±æ¨¡å¼é€‰æ‹©

### é…ç½®é©±åŠ¨çš„æ¨¡å¼é€‰æ‹©

```rust
// ä½ç½®ï¼šsrc/router_advanced.rs:110-117
pub async fn find_optimal_routes(&self, amount: f64) -> Vec<OptimizedPath> {
    match self.config.mode {
        RouterMode::Fast => self.fast_scan(amount).await,      // å¿«é€Ÿæ¨¡å¼
        RouterMode::Complete => self.complete_scan(amount).await, // å®Œæ•´æ¨¡å¼
        RouterMode::Hybrid => self.hybrid_scan(amount).await,  // æ··åˆæ¨¡å¼
    }
}
```

### ä¸‰ç§æ¨¡å¼å¯¹æ¯”

| ç‰¹æ€§ | Fast | Complete | Hybrid |
|------|------|----------|--------|
| **å»¶è¿Ÿ** | ~4ms | ~22ms | 4-22ms |
| **è·³æ•°** | 2-3è·³ | 2-6è·³ | è‡ªé€‚åº” |
| **ç®—æ³•** | Quick+BFS | Quick+BFS+Bellman-Ford | åŠ¨æ€é€‰æ‹© |
| **è¦†ç›–ç‡** | 73.8% | 100% | 85-100% |
| **é€‚ç”¨åœºæ™¯** | é«˜é¢‘äº¤æ˜“ | æ·±åº¦æŒ–æ˜ | å¹³è¡¡ |
| **CPUå ç”¨** | ä½ï¼ˆ13%ï¼‰ | é«˜ï¼ˆ28%ï¼‰ | ä¸­ï¼ˆ15-28%ï¼‰ |

---

### æ¨¡å¼1: Fastï¼ˆå¿«é€Ÿæ¨¡å¼ï¼‰

```rust
async fn fast_scan(&self, amount: f64) -> Vec<OptimizedPath> {
    let all_prices = self.price_cache.get_all_prices();
    
    // ğŸš€ å¹¶è¡Œè¿è¡Œä¸¤ä¸ªå¿«é€Ÿæ‰«æå™¨
    let (quick_paths, bfs_paths) = tokio::join!(
        async { self.quick_scanner.find_all_opportunities(amount) },
        async { self.bfs_scanner.find_all_opportunities(&all_prices, amount) }
    );
    
    // åˆå¹¶ã€å»é‡ã€æ’åº
    let mut all_paths = Vec::new();
    all_paths.extend(quick_paths);
    all_paths.extend(bfs_paths);
    
    // è½¬æ¢ä¸ºä¼˜åŒ–è·¯å¾„
    all_paths.into_iter()
        .map(|p| OptimizedPath::from_base(p))
        .collect()
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… è¶…ä½å»¶è¿Ÿï¼ˆ~4msï¼‰
- âœ… é€‚åˆé«˜é¢‘ç­–ç•¥
- âŒ å¯èƒ½æ¼æ‰æ·±å±‚æœºä¼šï¼ˆ4-6è·³ï¼‰

**é€‚ç”¨åœºæ™¯**ï¼š
- å¸‚åœºæ³¢åŠ¨å‰§çƒˆï¼Œéœ€è¦å¿«é€Ÿååº”
- äº¤æ˜“é¢‘ç‡ > 10æ¬¡/åˆ†é’Ÿ
- å¯¹å»¶è¿Ÿæ•æ„Ÿçš„ç­–ç•¥

---

### æ¨¡å¼2: Completeï¼ˆå®Œæ•´æ¨¡å¼ï¼‰â­ æ¨è

```rust
async fn complete_scan(&self, amount: f64) -> Vec<OptimizedPath> {
    // ğŸ“Š è·å–ä¸€è‡´æ€§å¿«ç…§ï¼ˆå…³é”®ï¼ï¼‰
    let consistent_prices = self.price_cache.get_consistent_snapshot(
        2000,  // 2ç§’æ–°é²œåº¦
        10     // 10 slotä¸€è‡´æ€§
    );
    
    // ğŸ”¥ ä¸‰è·¯å¹¶è¡Œæ‰«æ
    let (quick_paths, bfs_paths, deep_paths) = tokio::join!(
        async { self.quick_scanner.find_all_opportunities(amount) },
        async { self.bfs_scanner.find_all_opportunities(&all_prices, amount) },
        async { self.bf_scanner.find_all_cycles(&all_prices, amount) }
    );
    
    // åˆå¹¶æ‰€æœ‰ç»“æœ
    let mut all_paths = Vec::new();
    all_paths.extend(quick_paths);
    all_paths.extend(bfs_paths);
    all_paths.extend(deep_paths);
    
    // å»é‡ã€è¿‡æ»¤ã€ä¼˜åŒ–
    let deduplicated = self.deduplicate_paths(all_paths);
    let filtered = deduplicated.into_iter()
        .filter(|p| p.is_valid() && p.net_profit > 0.0)
        .collect();
    
    // åº”ç”¨æ‹†åˆ†ä¼˜åŒ–ï¼ˆDP/æ¢¯åº¦ä¸‹é™ï¼‰
    if self.config.enable_split_optimization {
        self.split_optimizer.optimize_all(&filtered, amount)
    } else {
        filtered
    }
}
```

**æ•°æ®ä¸€è‡´æ€§å¤„ç†**ï¼ˆé‡è¦ï¼ï¼‰ï¼š

```rust
// ğŸ¯ ä¸€è‡´æ€§å¿«ç…§
let consistent_prices = self.price_cache.get_consistent_snapshot(2000, 10);

// å¦‚æœæ•°æ®ä¸è¶³ï¼Œé™çº§åˆ°æ–°é²œåº¦è¿‡æ»¤
let all_prices = if consistent_prices.len() < 10 {
    self.price_cache.get_fresh_prices(5000)  // 5ç§’å†…çš„æ‰€æœ‰ä»·æ ¼
} else {
    consistent_prices
};
```

**ä»€ä¹ˆæ˜¯ä¸€è‡´æ€§å¿«ç…§**ï¼š
- **æ—¶é—´ä¸€è‡´æ€§**ï¼šæ‰€æœ‰ä»·æ ¼éƒ½åœ¨2ç§’å†…æ›´æ–°
- **Slotä¸€è‡´æ€§**ï¼šæ‰€æœ‰ä»·æ ¼çš„slotå·®å¼‚ä¸è¶…è¿‡10ä¸ªï¼ˆçº¦4ç§’ï¼‰
- **ç›®çš„**ï¼šé¿å…ç”¨è¿‡æœŸä»·æ ¼è®¡ç®—å¥—åˆ©ï¼Œå¯¼è‡´æ‰§è¡Œæ—¶å¤±è´¥

**ä¸ºä»€ä¹ˆéœ€è¦ä¸€è‡´æ€§**ï¼š

**åä¾‹ - ä¸ä¸€è‡´çš„æ•°æ®**ï¼š
```
Pool A (SOL/USDC): ä»·æ ¼168, slot=1000, æ—¶é—´=T+0s  â† æœ€æ–°
Pool B (USDC/USDT): ä»·æ ¼1.0,  slot=800,  æ—¶é—´=T-3s  â† è¿‡æœŸï¼
Pool C (USDT/SOL):  ä»·æ ¼0.006, slot=990, æ—¶é—´=T-0.5s â† è¾ƒæ–°

è®¡ç®—ç»“æœï¼šå‘ç°3è·³å¥—åˆ©ï¼ŒROI=5%ï¼
å®é™…æ‰§è¡Œï¼šPool Bä»·æ ¼å·²å˜åŒ–ï¼Œå®é™…äºæŸï¼
```

**æ­£ä¾‹ - ä¸€è‡´çš„æ•°æ®**ï¼š
```
Pool A: ä»·æ ¼168, slot=1000, æ—¶é—´=T+0s
Pool B: ä»·æ ¼1.0,  slot=995,  æ—¶é—´=T-0.2s  â† slotå·®å¼‚<10 âœ“
Pool C: ä»·æ ¼0.006, slot=998, æ—¶é—´=T-0.1s â† slotå·®å¼‚<10 âœ“

è®¡ç®—ç»“æœï¼šå¥—åˆ©æœºä¼šï¼ŒROI=2%
å®é™…æ‰§è¡Œï¼šä»·æ ¼ä»ç„¶æœ‰æ•ˆï¼Œå¥—åˆ©æˆåŠŸï¼
```

---

### æ¨¡å¼3: Hybridï¼ˆæ··åˆæ¨¡å¼ï¼‰ğŸ¯ æ™ºèƒ½

```rust
async fn hybrid_scan(&self, amount: f64) -> Vec<OptimizedPath> {
    // å…ˆå¿«é€Ÿæ‰«æ
    let quick_results = self.fast_scan(amount).await;
    
    // ğŸ¯ å†³ç­–é€»è¾‘ï¼šå¦‚æœå¿«é€Ÿæ‰«æå‘ç°ä¼˜è´¨æœºä¼šï¼Œç›´æ¥è¿”å›
    if let Some(best) = quick_results.first() {
        if best.optimized_roi > 1.0 {  // ROI > 1%
            info!("Found excellent quick opportunity ({}% ROI), skipping deep scan", 
                  best.optimized_roi);
            return quick_results;
        }
    }
    
    // å¦åˆ™ï¼Œè¿›è¡Œå®Œæ•´æ‰«æ
    debug!("No excellent quick opportunity, running complete scan...");
    self.complete_scan(amount).await
}
```

**å†³ç­–æ ‘**ï¼š
```
å¿«é€Ÿæ‰«æï¼ˆ4msï¼‰
    â†“
æ‰¾åˆ°é«˜ROIæœºä¼šï¼Ÿ
    â”œâ”€â”€ æ˜¯ï¼ˆROI>1%ï¼‰ â†’ âœ… ç›´æ¥è¿”å›ï¼ˆèŠ‚çœ18msï¼‰
    â””â”€â”€ å¦ï¼ˆROI<1%ï¼‰ â†’ ç»§ç»­å®Œæ•´æ‰«æï¼ˆ+18msï¼‰
```

**ä¼˜åŠ¿**ï¼š
- 90%æƒ…å†µä¸‹ç”¨Fastï¼ˆå¸‚åœºå¹³ç¨³æ—¶ï¼‰
- 10%æƒ…å†µä¸‹ç”¨Completeï¼ˆå¸‚åœºå¼‚å¸¸æ—¶ï¼‰
- å¹³å‡å»¶è¿Ÿï¼š~6-8msï¼ˆè€Œé22msï¼‰
- ä¸æ¼æ‰ä»»ä½•é‡è¦æœºä¼š

---

## ä¸‰å±‚ç®—æ³•è¯¦è§£

### Layer 1: Quick Scannerï¼ˆé—ç•™æ··åˆç®—æ³•ï¼‰

**å®ç°**ï¼š`src/router.rs`

**æ ¸å¿ƒæ€è·¯**ï¼šç›´æ¥å¥—åˆ© + ç®€å•ä¸‰è§’å¥—åˆ©

```rust
// ä¼ªä»£ç é€»è¾‘
for each quote_token (USDC, USDT, ...) {
    // 1. ç›´æ¥å¥—åˆ©ï¼šA â†’ B â†’ A
    for each base_token {
        find_path: quote â†’ base â†’ quote
        if profitable: add_to_results
    }
    
    // 2. ä¸‰è§’å¥—åˆ©ï¼šA â†’ B â†’ C â†’ A
    for each intermediate {
        find_path: quote â†’ base â†’ intermediate â†’ quote
        if profitable: add_to_results
    }
}
```

**ç‰¹ç‚¹**ï¼š
- ç®€å•ã€å¿«é€Ÿï¼ˆ~2msï¼‰
- åªè¦†ç›–å¸¸è§è·¯å¾„
- ç¡¬ç¼–ç æ¡¥æ¥ä»£å¸ï¼ˆUSDC/USDT/SOLï¼‰

**å‘ç°çš„æœºä¼šç±»å‹**ï¼š
- âœ… USDC â†’ SOL â†’ USDCï¼ˆç›´æ¥å¥—åˆ©ï¼‰
- âœ… USDC â†’ SOL â†’ USDT â†’ USDCï¼ˆä¸‰è§’å¥—åˆ©ï¼‰
- âŒ å¤æ‚çš„4+è·³è·¯å¾„

---

### Layer 2: BFS Scannerï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰â­ æ–°å¢

**å®ç°**ï¼š`src/router_bfs.rs`

**æ ¸å¿ƒç®—æ³•**ï¼š
```rust
pub fn find_all_opportunities(&self, pools: &[PoolPrice], amount: f64) -> Vec<ArbitragePath> {
    let mut results = Vec::new();
    
    // ä¸ºæ¯ä¸ªç¨³å®šå¸ä½œä¸ºèµ·ç‚¹
    for start_token in ["USDC", "USDT", "USDC.e"] {
        let mut queue = VecDeque::new();
        let mut visited_paths = HashSet::new();
        
        // åˆå§‹èŠ‚ç‚¹
        queue.push_back(PathNode {
            tokens: vec![start_token.to_string()],
            amount: amount,
            edges: vec![],
            total_fees: 0.0,
        });
        
        // BFSéå†
        while let Some(node) = queue.pop_front() {
            let current_token = node.tokens.last().unwrap();
            let depth = node.tokens.len() - 1;
            
            // â­ æ·±åº¦é™åˆ¶ï¼ˆ2-3è·³ï¼‰
            if depth >= self.max_depth {
                continue;
            }
            
            // æ£€æŸ¥æ˜¯å¦å½¢æˆå¾ªç¯
            if depth >= 2 && current_token == start_token {
                // âœ… æ‰¾åˆ°å¾ªç¯è·¯å¾„ï¼
                let profit = node.amount - amount;
                let roi = (profit / amount) * 100.0;
                
                if roi >= self.min_roi_percent {
                    results.push(self.build_arbitrage_path(node));
                }
                continue;
            }
            
            // ğŸ”¥ æ—©æœŸå‰ªæï¼šå¦‚æœå½“å‰åˆ©æ¶¦å·²ç»å¾ˆå·®ï¼Œæ”¾å¼ƒ
            if node.amount < amount * 0.95 {
                continue;  // å·²ç»äºæŸ5%ï¼Œä¸å¯èƒ½ç›ˆåˆ©äº†
            }
            
            // æ‰©å±•ï¼šæ·»åŠ æ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€è·³
            for pool in pools {
                if can_use_pool(pool, current_token) {
                    let next_amount = calculate_output(node.amount, pool);
                    let next_token = get_output_token(pool, current_token);
                    
                    // å»é‡ï¼šé¿å…é‡å¤è·¯å¾„
                    let path_signature = create_signature(&node.tokens, &next_token);
                    if !visited_paths.contains(&path_signature) {
                        visited_paths.insert(path_signature);
                        
                        queue.push_back(PathNode {
                            tokens: [...node.tokens, next_token],
                            amount: next_amount,
                            edges: [...node.edges, pool],
                            total_fees: node.total_fees + get_fee(pool),
                        });
                    }
                }
            }
        }
    }
    
    results
}
```

**ä¸ºä»€ä¹ˆBFSæ¯”Quickå¥½**ï¼š

1. **æ›´å…¨é¢çš„è·¯å¾„æœç´¢**
```
Quick: åªæ£€æŸ¥é¢„å®šä¹‰çš„æ¨¡å¼
  USDC â†’ SOL â†’ USDC
  USDC â†’ SOL â†’ USDT â†’ USDC

BFS: æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„ç»„åˆ
  USDC â†’ SOL â†’ USDC
  USDC â†’ SOL â†’ USDT â†’ USDC
  USDC â†’ RAY â†’ SOL â†’ USDC
  USDC â†’ mSOL â†’ SOL â†’ USDC
  ... æ•°ç™¾ç§ç»„åˆ
```

2. **æ—©æœŸå‰ªæ**
```rust
// å¦‚æœå½“å‰å·²ç»äºæŸ5%ï¼Œç«‹å³æ”¾å¼ƒ
if node.amount < amount * 0.95 {
    continue;  // çœç•¥åç»­è®¡ç®—
}
```

3. **å»é‡æœºåˆ¶**
```rust
// é¿å…é‡å¤æ¢ç´¢ç›¸åŒè·¯å¾„
let path_signature = "USDC->SOL->USDT";
if visited_paths.contains(&path_signature) {
    continue;  // è·³è¿‡å·²æ¢ç´¢çš„è·¯å¾„
}
```

**æ€§èƒ½**ï¼š
- æ—¶é—´ï¼š~2-4msï¼ˆ100ä¸ªæ± å­ï¼‰
- è¦†ç›–ï¼š2-3è·³æ‰€æœ‰è·¯å¾„
- å‰ªæç‡ï¼š70-80%ï¼ˆå‡å°‘æ— ç”¨è®¡ç®—ï¼‰

---

### Layer 3: Bellman-Ford Scannerï¼ˆæ·±åº¦è´Ÿç¯æ£€æµ‹ï¼‰

**å®ç°**ï¼š`src/router_bellman_ford.rs`

**æ ¸å¿ƒç®—æ³•**ï¼šBellman-Fordè´Ÿç¯æ£€æµ‹

```rust
pub fn find_all_cycles(&self, pools: &[PoolPrice], amount: f64) -> Vec<ArbitragePath> {
    // 1. æ„å»ºåŠ æƒæœ‰å‘å›¾
    let edges = self.build_weighted_graph(pools);
    
    // 2. åˆå§‹åŒ–ï¼šæ‰€æœ‰èŠ‚ç‚¹è·ç¦»ä¸ºæ— ç©·å¤§
    let mut distances: HashMap<String, f64> = HashMap::new();
    for token in get_all_tokens(&edges) {
        distances.insert(token, f64::INFINITY);
    }
    
    // 3. Bellman-Fordæ¾å¼›æ“ä½œï¼ˆN-1è½®ï¼‰
    for _ in 0..(self.max_hops - 1) {
        let mut updated = false;
        
        for edge in &edges {
            let old_dist = distances[&edge.from];
            let new_dist = old_dist + edge.weight;  // weightæ˜¯è´Ÿæ•°ï¼ˆå–å¯¹æ•°ï¼‰
            
            if new_dist < distances[&edge.to] {
                distances.insert(edge.to.clone(), new_dist);
                updated = true;
            }
        }
        
        if !updated {
            break;  // æå‰æ”¶æ•›
        }
    }
    
    // 4. ç¬¬Nè½®ï¼šæ£€æµ‹è´Ÿç¯ï¼ˆå¥—åˆ©æœºä¼šï¼‰
    let mut negative_cycles = Vec::new();
    
    for edge in &edges {
        let old_dist = distances[&edge.from];
        let new_dist = old_dist + edge.weight;
        
        if new_dist < distances[&edge.to] {
            // ğŸ¯ å‘ç°è´Ÿç¯ï¼
            let cycle = self.extract_cycle(edge, &edges);
            if let Some(cycle) = cycle {
                negative_cycles.push(cycle);
            }
        }
    }
    
    // 5. å¹¶è¡Œå¤„ç†ï¼ˆä½¿ç”¨Rayonï¼‰
    use rayon::prelude::*;
    negative_cycles.par_iter()
        .filter_map(|cycle| self.cycle_to_path(cycle, amount))
        .collect()
}
```

**æƒé‡è®¡ç®—ï¼ˆå…³é”®ï¼ï¼‰**ï¼š
```rust
// ä»·æ ¼æ¯”ç‡ â†’ å¯¹æ•°æƒé‡ï¼ˆè´Ÿæ•°è¡¨ç¤ºå¥—åˆ©ï¼‰
let price_ratio = reserve_out / reserve_in;
let weight = -price_ratio.ln();  // å–è´Ÿå¯¹æ•°

// ä¸ºä»€ä¹ˆç”¨å¯¹æ•°ï¼š
// ä¹˜æ³• â†’ åŠ æ³•ï¼šP1 * P2 * P3 â†’ ln(P1) + ln(P2) + ln(P3)
// å¥—åˆ©æ¡ä»¶ï¼šP1 * P2 * ... > 1
// ç­‰ä»·äºï¼šln(P1) + ln(P2) + ... > 0
// ç­‰ä»·äºï¼š-ln(P1) - ln(P2) - ... < 0ï¼ˆè´Ÿç¯ï¼‰
```

**ä¾‹å­**ï¼š
```
Pool 1: USDC â†’ SOL, ä»·æ ¼=0.006 (1 USDC = 0.006 SOL)
  weight = -ln(0.006) = 5.116

Pool 2: SOL â†’ USDT, ä»·æ ¼=170 (1 SOL = 170 USDT)
  weight = -ln(170) = -5.136

Pool 3: USDT â†’ USDC, ä»·æ ¼=1.0 (1 USDT = 1.0 USDC)
  weight = -ln(1.0) = 0

ç¯è·¯æ€»æƒé‡ = 5.116 + (-5.136) + 0 = -0.02 < 0 âœ“ è´Ÿç¯ï¼

å®é™…æ”¶ç›Šï¼š1 * 0.006 * 170 * 1.0 = 1.02 USDCï¼ˆ2%åˆ©æ¶¦ï¼‰
```

**ä¸ºä»€ä¹ˆBellman-Fordèƒ½æ‰¾åˆ°4-6è·³**ï¼š
- ä¸å—æ·±åº¦é™åˆ¶ï¼ˆç†è®ºä¸Šå¯ä»¥ä»»æ„è·³æ•°ï¼‰
- å…¨å±€ä¼˜åŒ–ï¼ˆæ‰¾åˆ°æœ€ä¼˜è´Ÿç¯ï¼‰
- å¯ä»¥å‘ç°å¤æ‚çš„å¥—åˆ©é“¾

**æ€§èƒ½ä¼˜åŒ–**ï¼š
```rust
// ğŸ”¥ å¹¶è¡ŒåŒ–ï¼ˆRayonï¼‰
use rayon::prelude::*;

let all_cycles: Vec<NegativeCycle> = tokens
    .par_iter()  // å¹¶è¡Œè¿­ä»£
    .filter_map(|start_token| {
        self.detect_cycles_from_token(start_token, &edges, &tokens)
    })
    .flatten()
    .collect();
```

**æ€§èƒ½**ï¼š
- æ—¶é—´ï¼š~10-14msï¼ˆ100ä¸ªæ± å­ï¼‰
- è¦†ç›–ï¼š2-6è·³æ‰€æœ‰è·¯å¾„
- å¹¶è¡ŒåŠ é€Ÿï¼š2-3å€

---

## ä¼˜åŒ–ç­–ç•¥

### 1. è·¯å¾„ç¼“å­˜ï¼ˆRouterCacheï¼‰

```rust
// ä½ç½®ï¼šsrc/router_cache.rs
pub struct RouterCache {
    cache: LruCache<CacheKey, CachedPath>,
    ttl: Duration,  // 30ç§’
}

impl RouterCache {
    pub fn get(&mut self, key: &CacheKey) -> Option<ArbitragePath> {
        if let Some(cached) = self.cache.get(key) {
            // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            if cached.timestamp.elapsed() < self.ttl {
                return Some(cached.path.clone());  // âœ… ç¼“å­˜å‘½ä¸­ï¼
            }
        }
        None
    }
}
```

**ç¼“å­˜é”®**ï¼š
```rust
struct CacheKey {
    start_token: String,
    amount_bucket: u64,  // æŒ‰é‡‘é¢åˆ†æ¡¶
    timestamp_bucket: u64, // æŒ‰æ—¶é—´åˆ†æ¡¶ï¼ˆ10ç§’ï¼‰
}
```

**æ•ˆæœ**ï¼š
```
ç¼“å­˜å‘½ä¸­ç‡: 60-80%
å»¶è¿Ÿé™ä½: 
  Completeæ¨¡å¼: 22ms â†’ 8ms (63%é™ä½)
  Fastæ¨¡å¼: 4ms â†’ 1.5ms (62%é™ä½)
```

---

### 2. æ‹†åˆ†ä¼˜åŒ–ï¼ˆSplit Optimizerï¼‰

**åœºæ™¯**ï¼šæ‰¾åˆ°å¤šæ¡ç›¸åŒå¥—åˆ©è·¯å¾„

```
å‘ç°3æ¡å¥—åˆ©è·¯å¾„ï¼š
  è·¯å¾„1: USDC â†’ SOL â†’ USDC, æµåŠ¨æ€§100k
  è·¯å¾„2: USDC â†’ SOL â†’ USDC, æµåŠ¨æ€§50k (ä¸åŒæ± å­)
  è·¯å¾„3: USDC â†’ mSOL â†’ SOL â†’ USDC, æµåŠ¨æ€§200k
  
é—®é¢˜ï¼šç”¨1000 USDCï¼Œå¦‚ä½•åˆ†é…ï¼Ÿ
```

**ç­–ç•¥1ï¼šåŠ¨æ€è§„åˆ’ï¼ˆå°é¢ï¼‰**
```rust
// é‡‘é¢ < 5000 USDC
fn optimize_with_dp(&self, paths: &[ArbitragePath], total_amount: f64) {
    // çŠ¶æ€ï¼šdp[i][j] = ä½¿ç”¨å‰iæ¡è·¯å¾„ï¼Œåˆ†é…jé‡‘é¢çš„æœ€å¤§æ”¶ç›Š
    // è½¬ç§»ï¼šdp[i][j] = max(
    //   dp[i-1][j],  // ä¸ç”¨ç¬¬iæ¡è·¯å¾„
    //   max_k { dp[i-1][j-k] + profit(path_i, k) }  // ç”¨ç¬¬iæ¡è·¯å¾„åˆ†é…k
    // )
    
    let num_buckets = 100;  // å°†é‡‘é¢åˆ†æˆ100ä»½
    let bucket_size = total_amount / num_buckets as f64;
    
    // DPçŸ©é˜µ
    let mut dp = vec![vec![0.0; num_buckets + 1]; paths.len() + 1];
    
    for i in 1..=paths.len() {
        for j in 0..=num_buckets {
            dp[i][j] = dp[i-1][j];  // ä¸ç”¨ç¬¬iæ¡è·¯å¾„
            
            // å°è¯•ç”¨ç¬¬iæ¡è·¯å¾„åˆ†é… 0 åˆ° j ä¸ªbucket
            for k in 0..=j {
                let allocation = k as f64 * bucket_size;
                let profit = self.calculate_profit_with_slippage(&paths[i-1], allocation);
                let total_profit = dp[i-1][j-k] + profit;
                
                dp[i][j] = dp[i][j].max(total_profit);
            }
        }
    }
    
    // å›æº¯æ‰¾åˆ°æœ€ä¼˜åˆ†é…
    backtrack_allocations(&dp, paths, total_amount)
}
```

**ç­–ç•¥2ï¼šæ¢¯åº¦ä¸‹é™ï¼ˆå¤§é¢ï¼‰**
```rust
// é‡‘é¢ â‰¥ 5000 USDC
fn optimize_with_gradient_descent(&self, paths: &[ArbitragePath], total_amount: f64) {
    let mut allocations = vec![total_amount / paths.len() as f64; paths.len()];
    let learning_rate = 0.1;
    let max_iterations = 100;
    
    for iteration in 0..max_iterations {
        // è®¡ç®—æ¢¯åº¦
        let gradients = self.compute_gradients(&allocations, paths);
        
        // æ›´æ–°åˆ†é…
        for i in 0..paths.len() {
            allocations[i] += learning_rate * gradients[i];
            allocations[i] = allocations[i].max(0.0);  // éè´Ÿçº¦æŸ
        }
        
        // å½’ä¸€åŒ–ï¼ˆæ€»å’Œ=total_amountï¼‰
        let sum: f64 = allocations.iter().sum();
        for i in 0..paths.len() {
            allocations[i] = allocations[i] * total_amount / sum;
        }
        
        // æ£€æŸ¥æ”¶æ•›
        if gradients.iter().all(|&g| g.abs() < 0.001) {
            break;
        }
    }
    
    allocations
}

fn compute_gradients(&self, allocations: &[f64], paths: &[ArbitragePath]) -> Vec<f64> {
    allocations.iter().zip(paths.iter()).map(|(amount, path)| {
        // è¾¹é™…æ”¶ç›Š = d(profit) / d(amount)
        let epsilon = 1.0;
        let profit_current = self.calculate_profit_with_slippage(path, *amount);
        let profit_plus = self.calculate_profit_with_slippage(path, *amount + epsilon);
        
        (profit_plus - profit_current) / epsilon
    }).collect()
}
```

**ä¸ºä»€ä¹ˆè¦æ‹†åˆ†**ï¼š

**ä¸æ‹†åˆ†ï¼ˆå•è·¯å¾„ï¼‰**ï¼š
```
1000 USDC â†’ è·¯å¾„1ï¼ˆæµåŠ¨æ€§100kï¼‰
æ»‘ç‚¹ï¼š1000 / 100000 = 1%
å®é™…è¾“å‡ºï¼š1000 * (1 - 0.0025 - 0.01) = 987.5 USDC
äºæŸï¼š12.5 USDC
```

**æ‹†åˆ†ï¼ˆå¤šè·¯å¾„ï¼‰**ï¼š
```
500 USDC â†’ è·¯å¾„1ï¼ˆæµåŠ¨æ€§100kï¼‰
  æ»‘ç‚¹ï¼š500 / 100000 = 0.5%
  è¾“å‡ºï¼š500 * (1 - 0.0025 - 0.005) = 496.25 USDC
  
500 USDC â†’ è·¯å¾„2ï¼ˆæµåŠ¨æ€§50kï¼‰
  æ»‘ç‚¹ï¼š500 / 50000 = 1%
  è¾“å‡ºï¼š500 * (1 - 0.0025 - 0.01) = 493.75 USDC

æ€»è¾“å‡ºï¼š496.25 + 493.75 = 990 USDC
åˆ©æ¶¦ï¼š-10 USDCï¼ˆæ¯”ä¸æ‹†åˆ†å¥½2.5 USDCï¼‰
```

---

## å®é™…æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šæ­£å¸¸å¸‚åœºï¼ˆHybridæ¨¡å¼ï¼‰

```
T=0s: SOL/USDCä»·æ ¼ä»168å˜ä¸º170ï¼ˆ+1.2%ï¼‰

Step 1: ä»·æ ¼è¿‡æ»¤
  âœ“ ä»·æ ¼æœ‰æ•ˆï¼ˆé0ï¼‰
  âœ“ å˜åŒ–æ˜¾è‘—ï¼ˆ1.2% > 0.001%ï¼‰
  âœ“ è¶…è¿‡é˜ˆå€¼ï¼ˆ1.2% > 1.0%ï¼‰
  â†’ è§¦å‘æ‰«æ

Step 2: Debounceæ£€æŸ¥
  âœ“ è·ç¦»ä¸Šæ¬¡æ‰«æ600msï¼ˆ> 500msï¼‰
  â†’ å…è®¸æ‰«æ

Step 3: å¹¶å‘æ§åˆ¶
  âœ“ å½“å‰å¹¶å‘=1ï¼ˆ< 3ï¼‰
  â†’ è·å¾—è®¸å¯

Step 4: è·¯ç”±æ‰«æï¼ˆHybridæ¨¡å¼ï¼‰
  a) Fastæ‰«æï¼ˆ4msï¼‰
     Quick: æ‰¾åˆ°2æ¡è·¯å¾„
     BFS: æ‰¾åˆ°5æ¡è·¯å¾„
     æœ€ä½³ROI: 0.8%
     
  b) å†³ç­–ï¼šROI=0.8% < 1%
     â†’ ç»§ç»­Completeæ‰«æ
     
  c) Completeæ‰«æï¼ˆ+18msï¼‰
     Bellman-Ford: æ‰¾åˆ°3æ¡æ·±å±‚è·¯å¾„
     æœ€ä½³ROI: 1.5%ï¼ˆ4è·³è·¯å¾„ï¼‰
     
  d) æ‹†åˆ†ä¼˜åŒ–
     ä½¿ç”¨DPå°†1000 USDCåˆ†é…åˆ°3æ¡è·¯å¾„
     ä¼˜åŒ–åROI: 1.8%

Step 5: è¿”å›ç»“æœ
  æ€»è€—æ—¶: 22ms
  æœºä¼šæ•°: 8æ¡ï¼ˆå»é‡å5æ¡ï¼‰
  æœ€ä½³: USDC â†’ SOL â†’ USDT â†’ mSOL â†’ USDC (1.8% ROI)
```

---

### æ¡ˆä¾‹2ï¼šé«˜æ³¢åŠ¨å¸‚åœºï¼ˆFastæ¨¡å¼ï¼‰

```
T=0s: å¸‚åœºå‰§çƒˆæ³¢åŠ¨ï¼Œ5ç§’å†…50æ¬¡ä»·æ ¼å˜åŒ–

Step 1-3: å‰10æ¬¡è§¦å‘é€šè¿‡è¿‡æ»¤

Step 4: ç¬¬11æ¬¡è§¦å‘
  Ã— Debounceæ‹’ç»ï¼ˆè·ç¦»ä¸Šæ¬¡ä»…200msï¼‰

Step 5: ç¬¬12æ¬¡è§¦å‘
  Ã— å¹¶å‘ä¸Šé™ï¼ˆå·²æœ‰3ä¸ªæ‰«æåœ¨è¿è¡Œï¼‰

Step 6: ç¬¬13æ¬¡è§¦å‘ï¼ˆè·ç¦»ç¬¬ä¸€æ¬¡è§¦å‘2ç§’ï¼‰
  âœ“ æ‰€æœ‰æ£€æŸ¥é€šè¿‡
  
  a) Fastæ‰«æï¼ˆ4msï¼‰
     Quick: 2æ¡è·¯å¾„
     BFS: 4æ¡è·¯å¾„
     æœ€ä½³ROI: 2.5%
     
  b) å†³ç­–ï¼šROI=2.5% > 1%
     âœ… ç›´æ¥è¿”å›ï¼Œè·³è¿‡Completeæ‰«æ
     
  æ€»è€—æ—¶: 4msï¼ˆèŠ‚çœ18msï¼‰
  æœºä¼šæ•°: 6æ¡
  æœ€ä½³: USDC â†’ SOL â†’ USDC (2.5% ROI)
```

---

### æ¡ˆä¾‹3ï¼šä»·æ ¼å™ªå£°ï¼ˆè¢«è¿‡æ»¤ï¼‰

```
T=0-10s: 10æ¬¡å¾®å°ä»·æ ¼æŠ–åŠ¨

ä»·æ ¼åºåˆ—ï¼š
  168.1234567 â†’ 168.1234568 (å˜åŒ–0.0000006%)
  168.1234568 â†’ 168.1234569 (å˜åŒ–0.0000006%)
  ...

Step 1: ä»·æ ¼è¿‡æ»¤
  âœ“ ä»·æ ¼æœ‰æ•ˆ
  Ã— å˜åŒ–<0.001%ï¼ˆå™ªå£°ï¼‰
  â†’ æ‰€æœ‰10æ¬¡éƒ½è¢«Filter 2æ‹’ç»

ç»“æœï¼š0æ¬¡æ‰«æè§¦å‘ï¼ŒèŠ‚çœ220ms CPUæ—¶é—´
```

---

## æ€»ç»“

æ‚¨çš„ç³»ç»Ÿé‡‡ç”¨äº†ä¸€ä¸ª**é«˜åº¦ä¼˜åŒ–çš„å¤šå±‚å†³ç­–æ¶æ„**ï¼š

### ğŸ¯ ä¸‰å±‚é˜²å¾¡ï¼ˆå‡å°‘æ— æ•ˆæ‰«æï¼‰
1. **ä»·æ ¼è¿‡æ»¤** - æ’é™¤99%å™ªå£°
2. **Debounce** - é˜²æ­¢è¿‡åº¦é¢‘ç¹
3. **å¹¶å‘æ§åˆ¶** - ä¿æŠ¤ç³»ç»Ÿç¨³å®š

### âš¡ ä¸‰å±‚ç®—æ³•ï¼ˆæœ€å¤§åŒ–è¦†ç›–ï¼‰
1. **Quick** - åŸºç¡€è·¯å¾„ï¼ˆé—ç•™ï¼‰
2. **BFS** - 2-3è·³å…¨è¦†ç›–ï¼ˆå¿«é€Ÿï¼‰
3. **Bellman-Ford** - 4-6è·³æ·±åº¦æŒ–æ˜ï¼ˆå…¨é¢ï¼‰

### ğŸ¨ ä¸‰ç§æ¨¡å¼ï¼ˆçµæ´»é€‚åº”ï¼‰
1. **Fast** - é«˜é¢‘åœºæ™¯ï¼ˆ4msï¼‰
2. **Complete** - å…¨é¢æŒ–æ˜ï¼ˆ22msï¼‰
3. **Hybrid** - æ™ºèƒ½å¹³è¡¡ï¼ˆ6-22msï¼‰

### ğŸš€ ä¸¤çº§ä¼˜åŒ–ï¼ˆæå‡åˆ©æ¶¦ï¼‰
1. **è·¯å¾„ç¼“å­˜** - é™ä½60-80%å»¶è¿Ÿ
2. **æ‹†åˆ†ä¼˜åŒ–** - æå‡10-30%åˆ©æ¶¦

**æœ€ç»ˆæ•ˆæœ**ï¼š
- å“åº”é€Ÿåº¦ï¼šæ¯«ç§’çº§
- è¦†ç›–ç‡ï¼š100%ï¼ˆCompleteæ¨¡å¼ï¼‰
- è¯¯æŠ¥ç‡ï¼š<1%ï¼ˆä¸‰å±‚è¿‡æ»¤ï¼‰
- CPUæ•ˆç‡ï¼š<30%ï¼ˆå¹¶å‘æ§åˆ¶ï¼‰
- åˆ©æ¶¦ä¼˜åŒ–ï¼š+10-30%ï¼ˆæ‹†åˆ†ç­–ç•¥ï¼‰

è¿™æ˜¯ä¸€ä¸ª**å·¥ä¸šçº§çš„é«˜æ€§èƒ½å¥—åˆ©ç³»ç»Ÿ**ï¼ğŸ¯



